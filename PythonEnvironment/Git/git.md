# 

- github cheatsheet
    
    https://education.github.com/git-cheat-sheet-education.pdf
    

## CLI

### CLI의 기초 개념 이해

개발 과정에서 CLI(Command Line Interface)를 이해하고 능숙하게 다루는 것은 매우 중요하다. 서버 환경을 설정하거나 애플리케이션을 운영할 때, GUI(Graphical User Interface)만으로 처리할 수 없는 작업이 자주 발생하기 때문이다. 또한 Git과 같은 버전 관리 도구 역시 CLI 기반으로 활용할 때 더 깊이 있는 사용이 가능하다. 따라서 CLI 기초 개념을 학습해두면 향후 서버 설정, 프로젝트 배포, 문제 해결 등 다양한 상황에서 능숙하게 대처할 수 있다.

# 1. CLI의 기초 개념 이해

## 1.1 CLI의 정의와 GUI와의 차이점

CLI(Command Line Interface)는 사용자가 텍스트 기반 명령어를 통해 컴퓨터와 상호 작용하는 방식을 말한다. GUI(Graphical User Interface)는 시각적 요소(아이콘, 버튼 등)를 활용해 직관적으로 시스템을 제어하는 환경인 반면, CLI는 키보드 입력을 통해 명령어를 직접 작성해야 한다는 특징이 있다.
**주요 특징:**

- **CLI**: 텍스트 기반, 높은 유연성, 풍부한 기능 활용 가능
- **GUI**: 시각적 인터페이스, 사용하기 직관적, 일부 고급 기능 구현이 어려울 수 있음

⠀CLI를 활용하면 스크립트를 작성해 반복 작업을 자동화할 수 있고, 서버 환경에 원격 접속하여 다양한 작업을 수행할 수 있다. 이러한 이유로 서버 운영이나 애플리케이션 배포가 잦은 백엔드 환경에서 CLI 활용 능력은 필수적이다.

## 1.2 운영체제별 터미널 프로그램 실행

CLI를 사용하기 위해서는 터미널(혹은 쉘) 프로그램을 실행해야 한다. 운영체제마다 기본적으로 제공되는 터미널 프로그램이 있으며, Windows의 경우 Git Bash를 설치하여 Unix 계열 명령어를 사용할 수 있다.

### 1.2.1 Windows: Git Bash

Windows 환경에서 Unix 계열 CLI 명령어를 사용하기 위해서는 Git Bash 설치를 권장한다. Git Bash는 Git을 설치하면 함께 제공되는 터미널 프로그램으로, 아래와 같은 절차를 통해 설치할 수 있다.

1. Git 공식 웹사이트(~https://git-scm.com/~)에서 Git 설치 파일을 다운로드한다.
2. 설치 마법사에 따라 Git을 설치한다.
3. **Git Bash**를 실행한다.
Git은 다음 학습에서 자세히 다룰 예정이므로, 현재 시점에서는 설치만 진행하고 Git Bash 사용 환경을 확인하면 된다.
**확인 방법 예시**

**check_git_version.sh**

```bash
git --version

```

위 명령어를 입력하면 설치된 Git의 버전을 확인할 수 있다. Git 버전 정보가 정상적으로 출력되면 Git Bash가 정상적으로 동작하는 것이다.

### 1.2.2 Mac: Terminal

Mac 환경에서는 **Terminal** 애플리케이션이 기본으로 설치되어 있어 추가 프로그램 설치 없이 Unix 계열 명령어를 바로 사용할 수 있다. 앱 런처(Launchpad) 혹은 Spotlight 검색에서 Terminal을 실행하면 된다.
**Git 설치 여부 확인**

- 일부 macOS 버전에는 Xcode Command Line Tools가 기본적으로 설치되어 있어 git --version을 입력하면 Git 버전이 표시될 수 있다.
    
    ```bash
    git --version
    
    ```
    

## 1.3 CLI 환경 설정 시 주의사항

CLI 환경에서 원활하게 개발을 진행하려면 몇 가지 설정을 확인하는 것이 좋다.

- **PATH 환경 변수**: 명령어 실행 시 파일을 찾는 경로를 정의한다. Git Bash나 Mac Terminal에서 새로운 프로그램을 설치한 경우, 설치 경로가 PATH에 등록되어 있는지 확인한다.
- **사용자 홈 디렉토리**: CLI 시작 위치가 사용자 홈 디렉토리인 경우가 많다. 작업 디렉토리를 일관성 있게 관리하기 위해 프로젝트별 폴더 구조를 정해두는 것이 좋다.
- **접근 권한**(permission)은 이번 학습에서는 다루지 않지만, 추후 서버 운영 및 파일 관리에서 매우 중요하므로 기본 개념을 숙지해두면 도움이 된다.

위에서 살펴본 내용을 통해 CLI에 대한 전반적인 개념과 환경 설정 방법을 이해할 수 있다. 다음 챕터에서는 디렉토리와 파일을 다루기 위한 기본적인 CLI 명령어 사용법을 다룰 예정이다. CLI 환경에 익숙해지면 프로젝트 전반을 쉽게 관리할 수 있고, Git 등 버전 관리 시스템이나 서버 배포 환경에서도 자유롭게 작업을 수행할 수 있다.

### 기본 명령어 학습 및 실습

이번 장에서는 CLI에서 가장 기초적이면서 자주 사용되는 명령어들을 학습한다. 디렉토리 및 파일을 탐색하고 관리하기 위한 명령어와, 텍스트 출력 및 파일 내용을 확인하는 명령어를 다룬다. 이러한 명령어들은 추후 Git 명령어 사용이나 서버 환경 구성 시에도 빈번하게 활용되므로, 예시 실습을 통해 사용법을 확실히 익혀두면 실무에서 큰 도움이 된다.

# 1. CLI 기초 명령어 학습 및 실습

## 1.1 디렉토리 탐색 및 관리

### 1.1.1 pwd

`pwd`(print working directory)는 현재 작업 디렉토리의 절대 경로를 출력한다.

- **사용 예시** - **pwd_example.sh**
예를 들어, /Users/student/workspace와 같은 경로가 출력된다.
    
    ```bash
    $ pwd
    
    ```
    

### 1.1.2 ls

`ls`는 현재 디렉토리(혹은 지정한 디렉토리)의 파일 및 하위 디렉토리 목록을 표시한다. 옵션을 붙여서 상세 정보나 숨김 파일 등을 볼 수 있다.

- **기본 사용 예시** 
현재 디렉토리 내의 폴더 및 파일 목록이 한 줄씩 출력된다.
    
    ```bash
    $ ls
    
    ```
    
- **자주 사용하는 옵션**
    - `ls -l`: 파일과 디렉토리의 상세 정보(권한, 소유자, 용량 등) 표시
    - `ls -a`: 숨김 파일 포함하여 모든 파일 표시

### 1.1.3 cd

`cd`(change directory)는 현재 작업 디렉토리를 변경한다.

- **사용 예시** - **cd_example.sh**
먼저 /Users/student/workspace 경로로 이동한 뒤, 이동된 디렉토리의 내용을 확인한다.
    
    ```bash
    $ cd /Users/student/workspace
    $ ls
    
    ```
    

## 1.2 파일 및 디렉토리 관리

### 1.2.1 mkdir

`mkdir`는 새로운 디렉토리를 생성한다.

- **사용 예시** 
myproject라는 새 디렉토리를 생성한 뒤, 그 디렉토리로 이동하여 현재 경로를 확인한다.
    
    ```bash
    $ mkdir myproject
    $ cd myproject
    $ pwd
    
    ```
    

### 1.2.2 touch

`touch`는 새로운 빈 파일을 생성하거나, 이미 존재하는 파일의 수정 시간을 갱신한다.

- **사용 예시** - [README.md](http://readme.md/) 파일이 새로 생성된 것을 확인할 수 있다.
    
    ```bash
    $ touch README.md
    $ ls -l
    
    ```
    

### 1.2.3 mv

`mv`는 파일이나 디렉토리를 이동하거나 이름을 변경할 때 사용한다.

- **이동 예시** - [README.md](http://readme.md/) 파일을 backup 디렉토리 안으로 이동한다.
    
    ```bash
    $ mkdir backup
    $ mv README.md backup/
    
    ```
    
- **이름 변경 예시** - README.md를 README_OLD.md로 이름을 변경한다.
    
    ```bash
    $ mv backup/README.md backup/README_OLD.md
    
    ```
    

### 1.2.4 cp

`cp`는 파일이나 디렉토리를 복사한다.

- **사용 예시** 
backup 디렉토리 안에 있는 README_OLD.md 파일을 현재 디렉토리로 복사한다.
    
    ```bash
    $ cp backup/README_OLD.md .
    $ ls
    
    ```
    

## 1.3 기본 출력

### 1.3.1 echo

`echo`는 뒤따르는 문자열을 출력한다. 간단한 정보를 화면에 표시하거나, 특정 텍스트를 파일에 기록할 때 자주 사용된다.

- **사용 예시** - **echo_example.sh**
터미널에 "Hello, CLI World!"가 그대로 출력된다.
    
    ```bash
    $ echo "Hello, CLI World!"
    
    ```
    

### 1.3.2 cat

`cat`은 텍스트 파일의 내용을 화면에 출력한다. 여러 파일을 연이어 확인하거나, 간단한 파일 생성·수정 용도로도 활용된다.

- **사용 예시** 
README_OLD.md 파일의 전체 내용을 터미널에 표시한다.
    
    ```bash
    $ cat README_OLD.md
    
    ```
    

이상으로 기본 CLI 명령어의 개념과 예시에 대해 살펴보았다. 해당 명령어들은 파일 및 디렉토리 관리를 위한 가장 기초적인 수준의 CLI 활용법에 해당하며, 이후 Git이나 기타 서버 관리 업무에서도 유용하게 사용될 것이다.

```bash
!cd content/project 
```

## Git 기본 개념 및 사용법

## Git 기초 개념 이해

## 1. 버전 관리의 필요성과 Git의 기본 원리

Git은 분산형 버전 관리 시스템으로, 여러 명의 개발자가 동시에 작업하더라도 각자의 로컬 저장소에서 작업한 후, 변경 이력을 원격 저장소에 동기화할 수 있는 강력한 도구입니다. 이 파트에서는 Git의 기본 개념부터 로컬 저장소 초기화, 기본 명령어 사용법, 그리고 .gitignore 파일 활용까지를 다룹니다.

---

### 2.1.1 버전 관리의 필요성

![image.png](attachment:15f84ff9-4712-4f24-9ca1-8b10f60e3860:image.png)

버전 관리는 프로젝트가 진행됨에 따라 변경된 이력을 체계적으로 기록하고, 필요한 시점에 이전 이력을 추적·복원할 수 있도록 하는 작업이다. 코드가 복잡해지거나 작업자(개발자)가 늘어날수록 그 중요성은 더 커진다. 다음은 버전 관리가 필요한 몇 가지 주요 상황적 예시다.

1. **동시 작업으로 인한 충돌 방지**
    - **예시**: 팀원 A와 팀원 B가 동시에 models.py 파일을 수정해야 하는 경우.
    - 버전 관리 없이 작업하면, 서로의 수정 사항이 뒤섞이거나 한쪽이 다른 쪽을 덮어쓸 위험이 있다.
    - Git을 통해 수정 이력을 분리 관리한 후 병합(merge)하면 충돌이 발생하더라도 변경 사항을 비교해 해결할 수 있다.
2. **과거 버전으로의 손쉬운 복원**
    - **예시**: 새로운 기능을 추가하던 중, 예상치 못한 오류로 프로젝트가 더 이상 정상 동작하지 않는 상황.
    - 버전 관리가 없다면, 누가 언제 무엇을 변경했는지 알아내기가 어렵다.
    - Git으로 변경 이력을 관리하고 있다면, 이전에 정상 동작하던 특정 시점으로 프로젝트를 빠르게 되돌릴 수 있다.
3. **여러 실험(시도) 간 이력 유지**
    - **예시**: 동일한 기능을 구현하되, 2~3가지 다른 구현 방법을 동시에 실험해보고 싶은 상황.
    - 버전 관리 없이 작업하면, 한 구현 방법을 다시 덮어써버려서 이전 코드를 완전히 잃을 수 있다.
    - Git을 사용하면 각 시도를 독립적으로 진행하고, 성과가 좋은 코드를 최종 프로젝트에 통합할 수 있다.
4. **변경 이력 추적 및 책임 소재 파악**
    - **예시**: 최근 버그가 언제, 누구에 의해, 어떤 코드 변경으로 인해 발생했는지 찾고 싶은 상황.
    - 버전 관리 없이 작업했다면, 전체 코드를 수동으로 비교하거나 구두로 확인해야 한다.
    - Git에서는 각 커밋마다 작성자 정보와 변경 이유(커밋 메시지)가 명확하게 기록되므로, 문제를 신속히 추적하고 해결할 수 있다.
    이처럼 버전 관리를 도입하면 협업 과정에서 발생하는 충돌을 줄이고, 과거 버전으로의 되돌림 및 여러 실험 간 이력을 유지하기가 훨씬 수월해진다.

### 2.1.2 Git의 기본 원리

Git은 **분산형 버전 관리 시스템**으로, 프로젝트의 전체 이력을 저장하는 **로컬 저장소**(Local Repository)를 각 개발자가 가질 수 있고, 이를 **원격 저장소**(Remote Repository)와 동기화하여 협업한다. Git에서 중요한 개념은 크게 **3가지 작업 영역**(워킹 디렉토리, 스테이징 영역, 저장소), 그리고 그 안에서 이뤄지는 **커밋(Commit)**과 **HEAD**이다.

### 2.1.3  Git의 3가지 작업 영역

Git은 수정된 파일을 버전으로 만들기까지 크게 세 단계(영역)를 거친다. 아래 **그림 1**은 각 영역이 어떤 역할을 하는지 간단히 표현한 예시다.

![이미지 출처 : https://velog.io/@wlals4264/Git ](attachment:4c877454-c554-4fa7-9eba-9db1029edda8:image.png)

이미지 출처 : https://velog.io/@wlals4264/Git 

**그림 1. Git의 3가지 작업 영역(개념도)**

1. **Working Directory (워킹 디렉토리)**
    - 실제로 코드 작성·편집·삭제 등을 수행하는 디렉토리다.
    - 코드 변경 후, 아직 커밋하지 않은 수정 사항은 이 워킹 디렉토리에만 반영되어 있다.
2. **Staging Area (스테이징 영역)**
    - 커밋하기 전에, “이번 커밋에 포함될 변경 사항”을 임시로 모아두는 공간이다.
    - 여러 파일 중 선택적으로 스테이징할 수 있어, 논리적으로 하나의 작업 단위가 되도록 커밋을 구성할 수 있다.
    - 즉, commit에 반영할 내용만 선별적으로 올리는 공간
3. **Repository (저장소)**
    - 커밋이 최종적으로 저장되는 영역이며, .git 디렉토리 내부에서 모든 버전 이력이 관리된다.
    - 여기에서 더 나아가 **로컬 저장소(Local Repository)**는 내 컴퓨터(개인 환경)에 있는 저장소를 말하고, **원격 저장소(Remote Repository)**는 팀원들이 함께 접근할 수 있는 서버(예: GitHub, GitLab 등)에 위치한 저장소를 말한다.
    - 일반적으로 각 개발자는 로컬 저장소에서 작업한 뒤, 확정된 작업 내용을 원격 저장소로 push하여 다른 사람과 공유한다. 반대로 다른 사람이 작업한 내용은 pull이나 fetch로 받아온다.
    - 즉, **로컬 저장소**는 개인 개발 환경에서의 변경 이력을 담당하며, **원격 저장소**는 협업을 위한 코드 공유와 통합 이력을 담당한다고 볼 수 있다.

![image.png](attachment:89931ef4-9445-4730-969e-27a486eaef94:image.png)

## 2. Commit과 버전

**Git에서 커밋(Commit)은 특정 시점의 변경 내용을 사진 찍듯이 스냅샷 형태로 저장하는 작업이다.** 

- 커밋(commit) : 프로젝트 디렉토리의 특정 모습을 하나의 버전으로 남기는 행위 & 결과물
- 레포지토리(repository) : 커밋이 저장되는 곳

각각의 커밋은 고유한 해시(hash)로 식별되며, 이 해시 값과 함께 작성자, 날짜, 커밋 메시지 등이 기록된다.
아래 **그림 2**는 세 번의 커밋이 쌓여가면서 버전이 형성되는 과정을 단순화해 나타낸 예시다.

```
 [ Commit A ] ---> [ Commit B ] ---> [ Commit C ]
   (초기버전)          (중간버전)          (최신버전)

```

![이미지 출처 : https://marklodato.github.io/visual-git-guide/index-ko.html ](attachment:99d63be0-88f0-40e0-8762-0ac51967560c:image.png)

이미지 출처 : https://marklodato.github.io/visual-git-guide/index-ko.html 

**그림 2. 커밋이 쌓여서 형성되는 버전 이력**

- **버전(Version)**은 각 커밋을 일컫는 또 다른 표현이다. Commit A가 “첫 번째 버전”, Commit C가 “최신 버전”이 되는 식으로 이해할 수 있다.
- commit의 구성요소
    - **해시 값(Hash)**: 각 Commit에는 고유한 해시 값이 할당됩니다. 이는 Commit을 식별하는 데 사용되며, Git 내부적으로 데이터 무결성을 보장하는 데 중요한 역할을 합니다.
    - **저자(Author)**: 이 필드는 Commit을 수행한 사람의 이름과 이메일 주소를 기록합니다. 협업하는 프로젝트에서 누가 해당 변경 사항을 만들었는지를 알 수 있게 해줍니다.
    - **메시지(Commit Message)**: Commit에 대한 설명을 포함합니다. 이 메시지는 변경 사항을 간략하게 요약하여, 다른 개발자들이 Commit의 목적을 쉽게 이해할 수 있도록 돕습니다.
- 커밋 메시지를 자세히 작성해두면 변경 의도와 내용을 쉽게 파악할 수 있어, 협업 및 디버깅 시 유용하다.
- 초보 개발자라도 자주 커밋해두면 변경 이력이 세밀하게 분할되어, 나중에 특정 시점만 되돌리거나 변경 사항을 확인하기가 훨씬 쉽다.

## 3. HEAD

Git에서 **HEAD**는 “현재 작업 중인 버전(커밋)”을 가리키는 특별한 포인터(pointer)다. 즉, HEAD가 어느 커밋을 향하고 있느냐에 따라 워킹 디렉토리가 해당 커밋의 상태를 반영한다. 다음 예시들은 HEAD를 이동하여 과거 버전을 확인하고, 다시 최신 버전으로 되돌아오는 과정을 단계별 그림으로 나타낸 것이다.

### 2.3.1 최신 버전(Commit C)을 가리키는 HEAD

```
┌─────────────────────┐
│  Commit C           │  ← HEAD
│ (최신 버전 상태)       │
└─────────────────────┘
         ↑
┌─────────────────────┐
│  Commit B           │
│ (중간 버전 상태)       │
└─────────────────────┘
         ↑
┌─────────────────────┐
│  Commit A           │
│ (초기 버전 상태)       │
└─────────────────────┘

```

**그림 3-1. HEAD가 최신 커밋(Commit C)을 가리키는 상태**

- 작업을 진행해오면서 축적된 최신 버전이 Commit C라고 가정한다.
- 이 시점에서 HEAD는 Commit C를 가리키고 있으며, 워킹 디렉토리는 이 최신 버전 상태를 반영한다.

### 2.3.2 과거 버전(Commit B)으로 HEAD 이동

```
┌─────────────────────┐
│  Commit C           │
│ (HEAD가 벗어난 상태)   │
└─────────────────────┘
         ↑
┌─────────────────────┐
│  Commit B           │  ← HEAD
│ (과거 버전 상태)       │
└─────────────────────┘
         ↑
┌─────────────────────┐
│  Commit A           │
│ (초기 버전 상태)       │
└─────────────────────┘

```

**그림 3-2. HEAD가 Commit B로 이동하여 중간 버전을 가리키는 상태**

- 과거에 정상 동작하던 버전을 확인하거나 수정 사항을 살펴보기 위해 HEAD를 Commit B로 이동(체크아웃 혹은 reset)할 수 있다.
- 이때 워킹 디렉토리는 Commit B 시점의 파일 상태로 바뀐다.
- 아직 Commit C 자체가 사라지는 것은 아니며, 단지 현재 HEAD가 과거 커밋을 가리키는 상태가 된다.

### 2.3.3 다시 최신 버전(Commit C)으로 HEAD 복귀

```
┌─────────────────────┐
│  Commit C           │  ← HEAD (복귀)
│ (최신 버전 상태)       │
└─────────────────────┘
         ↑
┌─────────────────────┐
│  Commit B           │
│ (중간 버전 상태)       │
└─────────────────────┘
         ↑
┌─────────────────────┐
│  Commit A           │
│ (초기 버전 상태)       │
└─────────────────────┘

```

**그림 3-3. HEAD를 다시 Commit C로 이동하여 최신 버전 상태로 돌아온 모습**

- 과거 버전 확인을 마친 후, HEAD를 다시 Commit C로 이동하면 최신 상태로 복구할 수 있다.
- 이 과정을 통해 Git은 어느 시점의 버전이라도 쉽게 이동(체크아웃)하며 내용 확인이 가능하고, 필요한 경우 이전 버전으로 되돌려 버그를 해결하거나 다른 작업을 진행할 수 있다.
이처럼 **HEAD**를 적절히 이동하는 방식으로 Git은 과거와 현재 버전을 오가며 개발 및 디버깅을 유연하게 수행할 수 있다. 문제가 발생했을 때, 과거 시점의 커밋을 빠르게 불러와 비교·분석함으로써 수정 시간을 단축할 수 있으며, 최신 버전에 다시 합류해 개발을 이어가는 것도 간단하다.

## 4. Git이 보는 파일의 4가지 상태

### Git 파일 상태 및 전환 요약

Git으로 관리되는 파일은 항상 **상태(status)**를 가지며, 이는 Git이 파일의 변동사항을 어떻게 추적하는지를 나타냅니다.

![image.png](attachment:96b13f96-c4c7-4333-8929-bdf45eb6d185:image.png)

### 1. 파일의 기본 상태

- **Untracked 상태:**
    
    Git이 해당 파일을 추적하지 않는 상태입니다.
    
    *예시:* 새로 생성한 파일에 대해 아직 `git add`를 수행하지 않은 경우.
    
- **Tracked 상태:**
    
    Git이 파일을 추적하는 상태로, 이후에는 다음 3가지 세부 상태로 나뉩니다.
    
    1. **Staged 상태:**
        
        파일의 변경사항이 스테이징 영역(인덱스)에 올라온 상태입니다.
        
        *예시:* 새 파일에 내용을 추가 후 `git add`를 하거나, 이미 커밋된 파일의 변경사항을 `git add`로 스테이징한 경우.
        
    2. **Unmodified 상태:**
        
        작업 디렉터리의 파일 내용이 최신 커밋과 동일하여 변경사항이 없는 상태입니다.
        
        *예시:* 커밋 직후 모든 파일은 이 상태가 됩니다.
        
    3. **Modified 상태:**
        
        최신 커밋에 비해 파일 내용에 변경이 발생한 상태입니다.
        
        *예시:* 커밋 후 파일을 수정했지만 아직 `git add`를 하지 않은 경우.
        

### 2. 상태 전환과 관련된 작업

- **Add the file:**
    - *동작:* `git add` 명령 실행
    - *전환:* Untracked 상태의 파일이 Staged 상태로 전환됨
- **Edit the file:**
    - *동작:* 파일 수정
    - *전환:* Unmodified 상태의 파일이 Modified 상태로 전환됨
- **Stage the file:**
    - *동작:* 수정된 파일에 대해 `git add` 실행
    - *전환:* Modified 상태의 파일이 Staged 상태로 전환됨
- **Remove the file:**
    - *동작:* 파일 삭제
    - *전환:* 파일이 Git의 추적 대상에서 제외됨 (삭제된 파일로 인식)
- **Commit:**
    - *동작:* `git commit` 명령 실행
    - *전환:* Staged 상태의 파일들이 커밋에 반영되어, 이후 모두 Unmodified 상태가 됨

---

## Git 기본 명령어 실습

## 1. Git 설치 및 초기 설정

### 1.1 Git 설치 확인

- **Unix 환경 (macOS, Linux, Git Bash/WSL 등)**
    
    ```bash
    git --version
    
    ```
    
- **Windows CMD (Git Bash 사용 권장)**
    
    ```
    git --version
    
    ```
    

설치가 되어 있다면 `git version 2.x.x` 와 같은 버전 정보가 출력됩니다. 설치가 안 되어 있다면 [Git 공식 사이트](https://git-scm.com/)에서 운영체제에 맞는 설치 파일을 다운로드 후 설치하세요.

### 1.2 사용자 정보 설정

Git은 각 커밋에 작성자 정보를 기록하기 때문에, 처음 사용할 때 올바른 사용자 이름과 이메일을 설정해야 합니다.

- **전역 설정 (모든 프로젝트에 적용)**
    
    ```bash
    $ git config --global user.name "홍길동"
    $ git config --global user.email "gildong@example.com"
    
    ```
    
- **설정 확인**
    
    ```bash
    $ git config --list
    
    ```
    

이렇게 설정하면 이후 생성하는 모든 로컬 저장소에서 동일한 사용자 정보가 사용됩니다. 프로젝트마다 다른 정보가 필요할 경우, 해당 프로젝트 폴더에서 `--global` 옵션 없이 설정할 수 있습니다.

## 2.로컬 저장소 초기화 및 기본 명령어

### 2.1 로컬 저장소 초기화 (git init)

새 프로젝트 디렉토리 내에서 Git을 초기화하면, 해당 디렉토리가 로컬 저장소로 등록됩니다.

```bash
$ mkdir my-git-project
$ cd my-git-project
$ git init

```

이 명령어를 실행하면, 숨겨진 `.git` 디렉토리가 생성되며, 이후 커밋 이력과 Git 설정 정보가 이곳에 저장됩니다.

### 2.2 파일 추가 및 커밋

1. **파일 생성 및 수정**
    
    예를 들어, `README.md` 파일을 생성하고 내용을 작성합니다.
    
    ```markdown
    # My Git Project
    
    이 저장소는 Git 기본 명령어 실습을 위한 예제 프로젝트입니다.
    
    ```
    
2. **스테이징 (git add)**
    
    ```bash
    $ git add README.md
    $ git add .  // 현재 프로젝트 디렉토리 내에서 변경사항이 생긴 모든 파일들을 staging area에 추가하라
    ```
    
    특정 파일 또는 현재 디렉토리의 모든 변경 사항을 스테이징할 수 있습니다.
    
    - 모든 파일 추가: `git add .`
    
    add를 하지 않는다면, 
    
    ![image.png](attachment:7c318fe7-625a-4242-8dad-60d9a301c7a9:image.png)
    
3. **커밋 (git commit)**
    
    스테이징된 변경 사항을 커밋하여 버전으로 기록합니다.
    
    ```bash
    $ git commit -m "Add initial README.md"
    
    ```
    
    커밋 메시지는 변경 사항의 의도와 내용을 간결하게 작성하는 것이 좋습니다.
    
    - Commit에 관한 주의 사항
        - 처음으로 커밋을 하기 전 사용자의 이름과 이메일 주소를 설정(config)
        - 커밋 메시지 남기기(옵션 -m)
        - 커밋할 파일을 git add로 지정해주기

### 2.3 상태 및 이력 확인

- **저장소 상태 확인 (git status)**
    
    ```bash
    $ git status
    
    ```
    
    워킹 디렉토리와 스테이징 영역의 상태를 확인할 수 있습니다.
    
- **커밋 이력 확인 (git log)**
    
    ```bash
    $ git log
    
    ```
    
    또는 간단히:
    
    ```bash
    $ git log --oneline
    
    ```
    
    - 작성자, 커밋 메시지, 커밋 시각, 해시 등을 확인할 수 잇습니다.
        
        ![image.png](attachment:4499c413-df3c-4fd5-b36f-e9391722dcbd:image.png)
        
    - `git log --oneline`은 해시와 메시지만 간략히 표시하며, `git log --graph`는 브랜치 구조를 시각화합니다.
    
- **변경 사항 비교 (git diff)**
    
    어떤 부분이 변경되었는지 한 줄 한 줄 비교하고 싶을 때 사용합니다. 
    
    ```bash
    $ git diff          # 워킹 디렉토리와 스테이징 영역 비교
    $ git diff --staged # 스테이징 영역과 마지막 커밋 비교
    
    ```
    
    - 수정된 줄 앞에 `+`(추가), (삭제) 표시를 확인할 수 있다.
    - 과거 커밋과 현재 커밋 간 차이를 비교하려면 `git diff <커밋해시> <커밋해시>` 등의 형식을 사용할 수도 있다.

### 2.4 변경 사항 취소 (git restore 및 git reset)

- **git restore**: 아직 커밋하지 않은 변경 사항을 되돌립니다. ([문서](https://git-scm.com/docs/git-restore))
    
    ```bash
    # 해당 파일의 작업 디렉토리에서 수정한 내용이 Git의 마지막 커밋 상태로 복원됩니다.
    # 주의: 스테이징 영역에 있는 변경 사항은 영향을 받지 않습니다.
    
    $ git restore README.md
    ```
    
- **git reset**: 커밋을 취소하거나 이전 상태로 되돌릴 때 사용합니다.
    
    ```bash
    $ git reset --soft HEAD^   # 최근 커밋 삭제(변경 사항은 스테이징 영역에 남음)
    $ git reset --mixed HEAD^  # 최근 커밋 삭제(변경 사항은 워킹 디렉토리에 남음)
    $ git reset --hard HEAD^   # 최근 커밋 삭제(변경 사항 모두 삭제; 주의!)
    
    ```
    
    ![image.png](attachment:f57f6922-5e6b-424e-8993-e21aec00eb0f:image.png)
    
    ![image.png](attachment:5da80ca5-25d7-4681-9a88-f72c9ffb5b5a:image.png)
    
    ![image.png](attachment:6fbdc9c0-6e48-418a-bf94-15a03a39478b:image.png)
    

## 3 .gitignore 파일 활용

프로젝트에 포함시키지 않을 파일이나 디렉토리를 지정하려면, 루트 디렉토리에 `.gitignore` 파일을 생성합니다.

### 3.1 .gitignore 파일 작성 예시

```
# 빌드 결과물
/build

# 로그 파일 및 임시 파일
*.log
*.tmp

# 환경 변수 파일
.env

```

- **주의**: 이미 추적 중인 파일은 .gitignore에 추가하더라도 자동으로 제외되지 않으므로, 필요 시 `git rm --cached <파일명>`을 사용하여 추적에서 제거합니다.

## 요약 및 정리

이번 파트를 통해 다음 내용을 학습했습니다.

- Git의 **버전 관리 필요성**과 **기본 원리**(워킹 디렉토리, 스테이징 영역, 저장소)
- Git **설치 확인**과 **사용자 정보 설정 방법**
- **로컬 저장소 초기화 (git init)** 및 파일 추가, 커밋, 상태 확인, 변경 사항 비교 방법
- **.gitignore** 파일을 활용하여 불필요한 파일을 관리하는 방법

## GitHub 및 협업 기능

Git은 분산 버전 관리 시스템으로, 로컬 저장소에서 작업한 내용을 원격 저장소와 동기화하여 팀원 간에 변경 이력을 공유할 수 있습니다. 이 파트에서는 원격 저장소의 개념, 연결 및 동기화 방법, 그리고 GitHub를 활용한 협업 기능을 중점적으로 다룹니다.

---

![이미지 출처 : https://tutorialeye.com/tutorial_single/difference-between-git-and-github](attachment:3dba5ea7-33ef-445a-bf25-3990d887a092:image.png)

이미지 출처 : https://tutorialeye.com/tutorial_single/difference-between-git-and-github

- **깃허브의 레포지토리 : 원격 레포지토리 or 리모트 레포지토리**
- **내 컴퓨터의 레포지토리 : 로컬 레포지토리**

## 4.1 원격 저장소의 개념과 필요성

- 원격 저장소(Remote Repository)는 인터넷 상의 서버(예: GitHub, GitLab, Bitbucket)에 위치하며, 여러 개발자가 동일한 코드를 공유하고 협업할 수 있게 도와줍니다.
- **주요 이점**
    - **협업 효율**: 모든 팀원이 동일한 저장소를 통해 변경 사항을 공유하므로, 충돌을 최소화할 수 있습니다.
    - **지속적 백업**: 로컬 저장소에 문제가 생기더라도 원격 저장소에 저장된 이력을 통해 복구가 가능합니다.
    - **배포 및 버전 관리**: 원격 저장소를 통해 릴리스 버전, 태그 등을 관리하며, 특정 시점의 코드 상태로 손쉽게 복원할 수 있습니다.

---

## 4.2 원격 저장소 연결 및 동기화

### 4.2.1 원격 저장소 등록 (git remote)

- **원격 저장소 추가**
    - **명령어**
    예:
        
        ```bash
        $ git remote add origin <원격 저장소 URL>
        ```
        
        ```bash
        $ git remote add origin git@github.com:username/my-git-project.git
        ```
        
    - 여기서 `origin`은 관례적으로 사용하는 원격 저장소 별칭입니다.
- **원격 저장소 목록 확인**
    - **명령어**
    → 등록된 원격 저장소의 push/pull URL을 확인할 수 있습니다.
        
        ```bash
        $ git remote -v
        
        ```
        
- **원격 저장소 삭제 및 이름 변경**
    - 삭제:
        
        ```bash
        $ git remote remove origin
        
        ```
        
    - 이름 변경:
        
        ```bash
        $ git remote rename oldname newname
        
        ```
        
- github에서 원격 레포지토리를 만들고 나면 뜨는 2개의 명령어
    
    ![image.png](attachment:bdf08c5e-1650-4c2a-902c-d9fd884bbe34:image.png)
    

---

### 4.2.2 원격 저장소 복제 (git clone)

- **복제의 개념**
    - 원격 저장소에 있는 코드를 로컬에 복제하면, 해당 프로젝트의 전체 히스토리가 함께 내려받아집니다.
- **명령어**
    
    ```bash
    # HTTPS 방식 (인증 토큰이나 사용자명/비밀번호 필요할 수 있음)
    $ git clone https://github.com/username/my-git-project.git
    
    # SSH 방식 (사전 설정한 SSH 키 사용)
    $ git clone git@github.com:username/my-git-project.git
    
    ```
    
- 복제 후, 자동으로 `origin`이라는 원격 저장소가 등록됩니다.

---

### 4.2.3 원격 저장소 동기화

### git push: 변경 사항 업로드

- **목적**: 로컬에서 작업한 커밋을 원격 저장소에 반영하여, 팀원과 공유합니다.
- **명령어**
    
    ```bash
    $ git push origin main
    
    ```
    
    - 처음 푸시 시에는 `u` 옵션을 사용해 기본 추적 브랜치로 설정할 수 있습니다.
        
        ```bash
        $ git push -u origin main
        
        ```
        
- 권한 없음 에러가 발생한다면
    
    ![이미지 출처 : https://itleaderbigongja.tistory.com/24 ](attachment:3c51f999-d0c8-4a2b-a752-6b058348a3ee:image.png)
    
    이미지 출처 : https://itleaderbigongja.tistory.com/24 
    

### git pull: 변경 사항 다운로드 및 병합

- **목적**: 원격 저장소의 최신 변경 사항을 로컬로 내려받아 자동 병합합니다.
- **명령어**
    
    ```bash
    $ git pull origin main
    
    ```
    
    - 이 명령어는 내부적으로 `git fetch`와 `git merge`를 동시에 수행합니다.
    - 충돌 발생 시 수동으로 해결해야 합니다.

### git fetch: 변경 사항 다운로드 (병합 X)

- **목적**: 원격 저장소의 최신 커밋들을 로컬에 내려받지만, 자동 병합은 하지 않습니다.
- **명령어**
    
    ```bash
    $ git fetch origin
    
    ```
    
- 이후, 원격 브랜치와의 차이를 확인하고 수동으로 병합할 수 있습니다.

---

## 4.3 GitHub 협업 기능 활용

GitHub는 원격 저장소 서비스 중 가장 널리 사용되며, 다양한 협업 도구를 제공합니다.

### 4.3.1 Pull Request (PR)를 통한 협업

Pull Request는 팀원 간에 코드 변경 사항을 검토하고 병합하기 위한 GitHub의 핵심 기능입니다.

- **PR 생성 과정**
    1. **기능별 브랜치 생성**: 각자 독립된 기능 작업을 위해 `feature/xxx` 형태의 브랜치를 생성 후 작업합니다.
    2. **원격 저장소에 푸시**: 작업한 브랜치를 원격 저장소에 업로드합니다.
        
        ```bash
        $ git push -u origin feature/xxx
        
        ```
        
    3. **GitHub 웹 인터페이스에서 PR 생성**: 해당 브랜치에서 main(또는 지정된 대상 브랜치)으로 병합 요청을 생성합니다.
    4. **코드 리뷰 및 피드백**: 팀원들이 변경 사항을 확인하고 피드백을 제공하며, 필요 시 수정합니다.
    5. **병합**: 리뷰가 완료되면 PR을 병합하여 main 브랜치에 반영합니다.
- **PR 템플릿 활용**
    - 저장소 내 `.github/pull_request_template.md` 파일을 생성하면, PR 작성 시 일정한 형식과 체크리스트가 자동 적용되어 효율적인 코드 리뷰가 가능합니다.

### 4.3.2 Fork

- **Fork 개념**
    - 직접 접근 권한이 없는 외부 기여자가 원본 저장소를 Fork하여 자신의 계정에서 작업 후 Pull Request를 통해 기여할 수 있습니다.
- **Fork 기반 협업 절차**
    1. **원본 저장소 Fork**: GitHub에서 Fork 버튼을 클릭합니다.
    2. **upstream 설정**: 원본 저장소를 `upstream`으로 등록하여 최신 변경 사항을 주기적으로 동기화합니다.
        
        ```bash
        $ git remote add upstream https://github.com/original_owner/original_repo.git
        
        ```
        
    3. **기능 개발 및 PR 생성**: Fork한 저장소에서 브랜치를 생성해 작업하고, PR을 작성합니다.

### 4. 3.3 Clone VS Fork

- **Clone:**
    - 리모트 저장소(예: GitHub)의 내용을 그대로 로컬 컴퓨터에 복사합니다.
    - 로컬에서 작업 후, 변경 사항을 원격 저장소로 푸시(push)할 수 있습니다.
- **Fork:**
    - 원본 저장소를 사용자의 GitHub 계정으로 복사하여 독립적인 새로운 리포지토리를 생성합니다.
    - 원본에 영향을 주지 않고 별도로 작업하며, 이후 Pull Request를 통해 변경 사항을 원본 저장소에 반영할 수 있습니다.

---

**Clone 후 Remote 변경 방법**

클론한 로컬 저장소의 원격 URL을 변경하려면 아래 명령어를 사용합니다.

1. **원격 URL 변경:**
    
    ```bash
    git remote set-url origin <새로운 원격 URL>
    
    ```
    
    예를 들어, 새로운 원격 저장소 URL이 `https://github.com/username/new_repo.git`인 경우:
    
    ```bash
    git remote set-url origin https://github.com/username/new_repo.git
    
    ```
    
2. **변경 확인:**
    
    변경된 원격 URL을 확인하려면 아래 명령어를 실행합니다.
    
    ```bash
    git remote -v
    
    ```
    

이렇게 하면 로컬 저장소의 `origin` 원격 URL이 새로운 저장소로 업데이트됩니다.

---

## 4.4 READ ME

**README 파일 자세한 설명**

**개념 및 역할**

- **README 파일의 정의:**
    - 프로젝트의 소개, 목적, 설치 방법, 사용법, 기여 방법 등을 담은 문서입니다.
    - 보통 `README`, `README.md`(Markdown 형식) 등으로 파일명을 사용합니다.

**주요 기능 및 특징**

- **프로젝트 개요 제공:** 프로젝트의 배경과 목표를 설명해 사용자 및 기여자에게 프로젝트의 전반적인 정보를 전달합니다.
- **설치 및 사용 방법 안내:**프로젝트를 설치하고 실행하는 방법, 필요 시스템 및 의존성 정보 등을 단계별로 안내합니다.
- **문서화 및 예제 제공:** API 사용법, 코드 예제, 기능 설명 등 상세한 정보를 제공하여 이해도를 높입니다.
- **기여 가이드라인 포함:** 외부 기여자가 프로젝트에 참여할 때 참고할 내용(코딩 규칙, 풀 리퀘스트(PR) 프로세스 등)을 포함합니다.
- **라이선스 및 저작권 정보:** 프로젝트의 법적 사용 조건 및 저작권 관련 정보를 명시합니다.

**작성 시 고려 사항**

- **명확성과 간결성:** 불필요한 정보는 배제하고, 핵심 내용만 간결하게 작성하는 것이 좋습니다.
- **포맷 및 문법:** Markdown 형식을 사용하면 제목, 목록, 코드 블록 등을 효과적으로 구성할 수 있습니다.
- **최신 정보 유지:** 프로젝트 업데이트 시 README도 함께 최신 상태로 유지하여 사용자 혼선을 방지해야 합니다.

 **참고 링크**

- [GitHub 도움말 – README 작성하기](https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/about-readmes)
- [Markdown 기본 문법 안내](https://guides.github.com/features/mastering-markdown)

## 4.5 요약

이번 파트를 통해 학습한 주요 내용은 다음과 같습니다.

- **원격 저장소의 개념과 필요성**: 협업 및 백업을 위한 중앙화된 코드 저장소
- **원격 저장소 연결 및 동기화**: `git remote`, `git clone`, `git push`, `git pull`, `git fetch` 명령어 활용
- **GitHub 협업 기능**: 계정 생성, SSH 키 설정, Pull Request와 Fork를 통한 협업 방식

## 종합 시나리오 예제

다음은 간단히 전체 흐름을 재현한 시나리오다.

1. **디렉토리 생성 및 이동**
    
    ```bash
    $ mkdir my-git-project
    $ cd my-git-project
    
    ```
    
2. **Git 초기 설정 확인**
    
    ```bash
    $ git config --list
    
    ```
    
    - 필요시 `git config --global user.name`, `git config --global user.email` 설정.
3. **저장소 초기화**
    
    ```bash
    $ git init
    
    ```
    
4. **파일 생성**
    - `README.md` 파일에 프로젝트 소개 작성.
5. **스테이징 및 커밋**
    
    ```bash
    $ git add README.md
    $ git commit -m "Add initial project README"
    
    ```
    
6. **파일 수정 후 재커밋**
    - README.md에 버전 정보 추가.
    
    ```bash
    $ git add README.md
    $ git commit -m "Update README with version info"
    
    ```
    
7. **선택 사항**
    1. **상태 확인**
        
        ```bash
        $ git status
        $ git log --oneline
        
        ```
        
    2. **.gitignore 생성**
        - `.gitignore` 파일 작성 후, 빌드 디렉토리(`build/`)나 임시 파일(`.log`) 등 무시 목록을 추가.
    3. **변경 취소·되돌리기**
        - `git restore`로 수정 사항을 되돌리거나, `git reset`을 통해 커밋을 취소해 이전 버전으로 돌아갈 수 있다.
8. GitHub Repo와 내 로컬 프로젝트랑 연결
    
    ```bash
    git remote add origin [github repo 링크]
    ```
    
9. 잘 연결됐는지 확인(선택사항)
    
    ```bash
    git remote -v
    ```
    
10. GitHub으로 올리기
    
    ```bash
    git push origin main
    ```
    

---

## Git 브랜치의 이해와 활용

### Git의 작업 관리 개념 이해

이번 교재에서는 Git에서 작업을 관리하기 위한 핵심 개념인 **브랜치**와 **태그**를 다룬다. 브랜치와 태그는 동시에 여러 작업을 진행하고, 특정 시점을 버전으로 기록하여 관리하는 데에 필수적인 도구다. 특히, 초급 개발자 입장에서 이해하기 쉽게, 각각의 개념이 왜 필요한지와 어떤 방식으로 적용되는지 그림과 함께 알아본다.

# 1. 작업 관리의 필요성

Git을 사용하지 않고도 코드를 버전별로 관리할 수 있지만, 실제 개발 현장에서는 여러 사람이 동시에 작업하고, 다양한 변경사항을 기록하며, 배포 가능한 안정 버전을 추적해야 하는 복잡성이 발생한다. 이러한 문제를 해결하기 위해서는 별도의 독립적인 작업 공간을 쉽게 만들고(브랜치), 중요한 이력을 기록할 방법(태그)이 필요하다.

## 1.1 동시 다발적 개발의 필요성

- 여러 기능을 동시에 개발하려면 작업을 나누어 진행해야 한다.
- 각 기능이 서로 충돌하지 않도록 격리된 공간에서 작업할 수 있어야 한다.
- 특정 기능을 테스트 또는 검증하는 동안에도 다른 기능을 병행해서 개발할 수 있어야 한다.

## 1.2 안정적인 버전 관리의 중요성

- 제품을 배포할 때, “이 시점의 코드는 안정적”이라고 표시할 수 있는 방법이 필요하다.
- 문제 발생 시 과거 버전으로 쉽게 돌아가거나, 특정 버전만 재배포할 수 있어야 한다.
- 개발 프로세스 중간에 언제든지 이전 변경사항을 추적하고 참고할 수 있어야 한다.

# 2. 브랜치(Branch)

Git에서 브랜치는 격리된 작업 공간을 의미한다. 브랜치를 활용하면 메인 흐름(main 브랜치)을 건드리지 않고도 여러 가지 실험적 기능을 독립적으로 개발하고, 작업이 끝나면 다시 통합(병합)할 수 있다.

## 2.1 브랜치의 정의와 역할

- **정의**: 특정 시점의 전체 코드 이력을 기반으로 새롭게 분기된 작업 영역
- **역할**: 메인 코드와 분리된 상태에서 기능을 개발하거나 버그를 수정하고, 필요할 때만 통합
- **이점**: 작업 과정이 다른 부분과 충돌하지 않으므로, 안정성과 생산성 모두를 확보 가능

## 2.2 브랜치 개념도

아래 그림은 브랜치가 어떻게 독립적인 작업 흐름을 형성하는지 간단히 나타낸다.

```
A → B → C → F    (main 브랜치)
         \
          D → E  (feature/login 브랜치)

```

**그림 1: 브랜치를 통한 독립적인 작업 흐름 예시**

1. **A, B, C 커밋 (main 브랜치)**
    - 메인 브랜치에서 일정 기간 동안 기능 개발과 버그 수정이 이루어져 A, B, C 커밋이 쌓인다.
    - C 커밋 시점에서 새로운 기능(로그인 기능)을 추가하기로 결정했다.
2. **분기(Branch) 생성**
    - feature/login이라는 브랜치를 **C 커밋** 기준으로 분기한다.
    - 이렇게 생성된 새 브랜치에서는 D, E 커밋을 통해 로그인 기능을 독립적으로 개발할 수 있다.
3. **브랜치의 격리 효과**
    - 로그인 기능이 완성될 때까지, 메인 브랜치와 충돌 없이 자유롭게 수정·테스트 가능하다.
    - 다른 팀원이 동시에 메인 브랜치에서 다른 작업(F 커밋)을 진행해도 상호 간섭이 일어나지 않는다.
4. **브랜치 병합 (향후)**
    - 기능 개발이 완료되고 충분히 안정화되면, feature/login 브랜치를 다시 메인 브랜치로 병합(merge)해 전체 코드베이스에 반영한다.
    - 이후 필요 없다면 feature/login 브랜치는 삭제해 작업 흐름을 정리할 수 있다.

## 2.3 커밋과 브랜치의 관계

- 브랜치는 단순히 “어디서부터 새 작업을 시작할 것인가”를 가리키는 포인터(pointer)에 가깝다.
- 새로운 브랜치를 만들면, 해당 브랜치가 자동으로 방금 만든 커밋을 가리키게 된다.
- 브랜치마다 서로 다른 커밋 이력을 가질 수 있으므로, 여러 기능을 병렬로 개발 가능하다.

# 3. 태그(Tag)

태그는 Git에서 특정 커밋에 쉽게 식별 가능한 이름(예: 버전 번호)을 붙이는 기능이다. 흔히 안정 버전이나 배포 버전, 혹은 중요한 시점에 태그를 달아두어, 나중에 그 시점을 다시 확인하거나 복원하기 쉽게 만든다.

## 3.1 태그의 정의와 역할

- **정의**: 특정 커밋에 붙이는 ‘이름표’
- **역할**: 릴리스 버전, 마일스톤 등 중요한 지점을 빠르게 찾고 관리
- **이점**: 태그로 표시된 상태를 빠르게 확인하거나 복원 가능

## 3.2 태그 개념도

아래 그림은 태그가 어떻게 특정 커밋을 식별하고, 해당 시점을 가리키는지 보여준다.

```
      (v1.0) - tag
        ↓
A → B → C → F    (main 브랜치)
         \
          X → Y  (bugfix/hotfix 브랜치)
              ↑
        (hotfix_v1.0.1) - tag

```

**그림 2: 태그를 통한 특정 버전 식별 예시**

1. **A, B, C 커밋 (main 브랜치)**
    - A → B → C 순으로 주요 기능을 개발한다.
    - C 커밋이 충분히 안정적이라고 판단되어, `v1.0` 태그를 붙이고 배포를 진행한다.
2. **긴급 버그 발견**
    - 배포 후 긴급 버그가 발견되었다고 가정한다.
    - 이 버그를 빠르게 수정하기 위해, `C (v1.0)` 커밋 지점에서 **bugfix/hotfix 브랜치**를 만든다.
3. **X, Y 커밋 (bugfix/hotfix 브랜치)**
    - 브랜치를 분기한 뒤, 버그 수정 작업을 진행하면서 X, Y 커밋을 만든다.
    - 모든 수정이 완료된 시점(커밋 Y)에서 새 태그 `hotfix_v1.0.1`을 붙여 핫픽스 버전을 배포한다.
4. **태그를 활용한 버전 식별**
    - `v1.0` 태그: 메인 브랜치에서 정식 배포했던 버전
    - `hotfix_v1.0.1` 태그: 긴급 수정 버전
    - 각 태그를 통해 “어떤 커밋을 기준으로, 어떤 변경이 들어가서 배포되었는지”를 명확히 확인할 수 있다.

### 주요 포인트

- **메인 브랜치의 태그**(예: `v1.0`): 새 기능이 정상 동작하여 배포 가능한 시점에 붙이는 ‘공식 버전’
- **핫픽스 브랜치의 태그**(예: `hotfix_v1.0.1`): 기존 배포 버전에서 발견된 문제를 긴급하게 수정한 버전을 명시
- **실무 활용**:
    - 긴급 버그 발생 시, 마지막 안정 버전에 태그가 달려 있으므로 해당 커밋을 정확히 찾아 브랜치로 분기
    - 버그 수정이 완료되면 또 다른 태그를 붙여 새 버전을 빠르게 배포
    - 이후 필요하다면 bugfix/hotfix 브랜치를 main에 병합해 코드를 동기화

## 3.3 브랜치와 태그의 차이점

- **목적**
    - 브랜치: 새 기능 개발, 버그 수정 등 ‘새로운 이력’을 만들어나가는 작업 단위
    - 태그: 이미 완성된 특정 시점을 ‘이름표’로 고정하여 참조하는 방식
- **동적인가, 정적인가**
    - 브랜치: 커밋이 추가될 때마다 가리키는 커밋이 바뀌는 ‘동적’ 포인터
    - 태그: 한 번 태그를 달면 해당 시점을 ‘고정’하는 ‘정적’ 포인터
- **사용 시점**
    - 브랜치: 언제든지 새 기능/실험을 시작하거나 다른 흐름으로 분리해야 할 때
    - 태그: 중요한 버전(예: `v1.0`)이나 릴리스 시점, 특정 기능이 완료된 지점 표시

## 3.4 언제 브랜치를 쓰고, 언제 태그를 쓸까?

- **브랜치**는 작업을 진행할 때나 병렬 개발이 필요할 때 사용한다.
    - 예: 새로운 기능A, 기능B를 각각 독립적으로 개발하여, 모든 테스트가 끝나면 메인에 병합
- **태그**는 릴리스 버전이나 백업 포인트, 배포 등 특정 시점을 보존하고 싶을 때 사용한다.
    - 예: v1.0으로 배포 후, 문제가 생기면 그 버전 코드만 재배포하거나 패치 버전을 만들 수 있음

위 내용에서 브랜치와 태그의 개념을 간단히 살펴보았다. 다음 학습에서는 실제로 브랜치를 생성하고 병합하며, 충돌이 발생했을 때 해결하는 과정을 실습해볼 예정이다.

### 브랜치와 태그 활용하기

이번 교재에서는 **브랜치와 태그**를 실무 상황에서 어떻게 활용하는지 구체적으로 살펴본다. 이전에 브랜치와 태그의 개념을 이해했다면, 이제 실제 명령어와 시나리오를 통해 독립적으로 작업을 진행하고 특정 버전을 관리하는 방법을 학습한다. 주요 포인트는 기능 개발 브랜치 생성·이동·삭제와 태그를 통한 버전 기록, 그리고 시맨틱 버저닝을 도입해 체계적으로 버전을 관리하는 것이다.

# 1. 기능 개발을 위한 브랜치 관리

## 1.1 브랜치 목록 확인 및 생성

브랜치를 활용하면, 개발 중인 코드를 안정적인 상태로부터 분리하여 안전하게 기능을 수정하거나 추가할 수 있다.

### 1.1.1 브랜치 목록 확인

- **명령어**
현재 로컬 저장소에 존재하는 모든 브랜치 목록이 표시된다. 현재 작업 중인 브랜치는 별표(*)와 함께 표시된다.
    
    ```bash
    $ git branch
    
    ```
    

### 1.1.2 브랜치 생성

- **명령어**
특정 시점(HEAD가 가리키는 커밋)에서 새 브랜치를 만든다. 이 시점부터 독립된 작업이 가능하다.
    
    ```bash
    $ git branch 새브랜치이름
    
    ```
    
- **예시 시나리오**
    - 메인 브랜치(`main`)가 안정화된 상태에서, 로그인 기능을 새로 개발하기 위해 `feature/login` 브랜치를 생성한다. 이후 이 브랜치에서 자유롭게 코드를 수정하고 커밋을 쌓아갈 수 있다.

## 1.2 작업 브랜치 전환

기존에 있던 브랜치로 이동하거나, 새 브랜치를 만들면서 바로 전환할 수도 있다.

### 1.2.1 기존 브랜치로 이동

- **명령어**
해당 브랜치가 가리키는 커밋 상태로 워킹 디렉토리를 전환한다.
    
    ```bash
    $ git checkout 브랜치이름
    
    ```
    

### 1.2.2 새 브랜치 생성과 동시에 이동

- **명령어**
새 브랜치를 만들고, 즉시 그 브랜치로 이동한다.
    
    ```bash
    $ git checkout -b 새브랜치이름
    
    ```
    
- **예시**
현재 작업 중인 커밋(HEAD)을 기준으로 `feature/payment` 브랜치를 만들고 전환한다.
    
    ```bash
    $ git checkout -b feature/payment
    
    ```
    

## 1.3 완료된 브랜치 정리

브랜치에서 기능 개발을 마친 뒤, 더 이상 불필요해졌다면 삭제하여 저장소를 깔끔하게 유지할 수 있다.

### 1.3.1 브랜치 삭제

- **명령어**
이미 병합된 브랜치는 -d 옵션으로 삭제할 수 있다. 병합되지 않은 커밋이 있으면 경고가 발생한다.
    
    ```bash
    $ git branch -d 브랜치이름
    
    ```
    
- **강제 삭제**
아직 병합되지 않은 커밋이 있어도 강제로 삭제한다. 신중히 사용해야 한다.
⠀
    
    ```bash
    $ git branch -D 브랜치이름
    
    ```
    

# 2. 주요 버전 관리를 위한 태그 활용

## 2.1 태그 생성

태그는 특정 커밋을 명확히 식별하기 위해 붙이는 ‘이름표’다. 보통 릴리스 버전이나 중요한 시점(마일스톤)이 있을 때 태그를 생성한다.

### 2.1.1 기본 태그 생성

- **명령어**
HEAD(현재 작업 중인 커밋)에 태그를 붙인다.
    
    ```bash
    $ git tag 태그이름
    
    ```
    
- **예시**
현재 커밋을 “v1.0”이라는 이름으로 태그한다.
    
    ```bash
    $ git tag v1.0
    
    ```
    

### 2.1.2 주석(-a) 태그 생성

- **명령어**
커밋에 대한 설명 메시지(annotated tag)를 포함하여 태그를 생성한다.
    
    ```bash
    $ git tag -a v1.0 -m "Release version 1.0"
    
    ```
    
- **이점**
    - 누가, 언제 태그를 달았는지 등의 메타데이터를 저장한다.
    - 팀원 간 릴리스 노트를 공유할 때 편리하다.

## 2.2 시맨틱 버저닝 이해하기

시맨틱 버저닝은 버전 번호를 “MAJOR.MINOR.PATCH” 형태로 관리하는 방식이다.

- **MAJOR**: 이전 버전과 호환되지 않는 큰 변화
- **MINOR**: 이전 버전과 호환되는 새로운 기능 추가
- **PATCH**: 호환되는 버그 수정

### 2.2.1 버전 번호 예시

- `v1.0.0`: 사용자 로그인과 상품 목록 조회 기능이 포함된 첫 릴리스
- `v1.1.0`: 장바구니 및 할인 쿠폰 기능을 새로 추가
- `v1.1.1`: 특정 상황에서 할인 쿠폰이 적용되지 않는 버그를 패치
- `v1.2.0`: 다양한 결제 수단 및 분할 결제를 지원하는 새로운 기능을 추가
- `v2.0.0`: 대규모 개편으로 DB 구조 변경 및 다국어 지원을 적용
프로젝트가 커지고 협업 인원이 늘어날수록, 시맨틱 버저닝을 적용하면 버전 간 호환성과 변경 규모를 추적하기 쉽다.

## 2.3 개발 단계별 태그 전략

버전을 기록하고 싶을 때, 다음과 같은 태그 정책을 활용할 수 있다.

- **스냅샷 태그**: 간단한 내부 테스트용(예: `v1.0-alpha`, `v1.0-beta`)
- **RC(Release Candidate)**: 정식 릴리스 직전 단계(예: `v1.0-rc1`)
- **정식 릴리스**: `v1.0`, `v1.1`, `v2.0` 등 최종 안정 버전 태그

## 2.4 태그로 특정 버전 상태 확인 및 복원

이미 태그가 붙어 있는 버전으로 다시 돌아가거나, 해당 시점을 기반으로 새 브랜치를 만들 수도 있다.

### 2.4.1 태그 목록 확인

- **명령어**
저장소 내에 존재하는 모든 태그를 나열한다.
    
    ```bash
    $ git tag
    
    ```
    

### 2.4.2 태그 참조로 체크아웃

- **명령어**`v1.0` 태그가 달린 커밋의 상태를 워킹 디렉토리에 가져온다.
(Detached HEAD 상태로 전환되므로, 변경 후 새 브랜치를 생성하는 방식으로 관리하는 것이 일반적이다.)
⠀
위에서 브랜치와 태그를 활용하는 대표적인 시나리오와 명령어를 살펴보았다.
    
    ```bash
    $ git checkout v1.0
    
    ```
    
- 브랜치를 사용하면 기능 개발을 격리해서 진행하고, 완료 후 통합할 수 있다.
- 태그를 사용하면 중요한 버전을 쉽게 식별·복원할 수 있다.

앞서 배운 개념과 함께 이번 장에서 학습한 실습을 반복해 보면, Git 기반 협업 과정에서 기능 개발과 버전 관리를 훨씬 체계적으로 진행할 수 있을 것이다.

### 브랜치 병합과 충돌 해결

이번 챕터에서는 **브랜치 병합**과 **충돌 해결**에 대해 살펴본다. 브랜치를 나누어 독립적으로 작업하더라도, 최종적으로 하나의 통합 버전을 만들어야 할 때가 오며, 이 과정에서 충돌이 발생할 수도 있다. 먼저 병합의 개념과 방식을 살펴본 뒤, 이어서 충돌이 무엇이고 어떻게 해결하는지 알아본다.

# 1. 브랜치 병합하기

## 1.1 개념

브랜치 병합(Merge)이란, 서로 다른 브랜치에서 진행된 커밋 이력을 하나로 합치는 과정이다. Git은 다음 두 가지 주요 병합 방식을 제공한다.

1. **Fast-forward Merge**
    - 병합 대상 브랜치가 현재 브랜치의 최신 커밋에서 분기되어 직선형 이력을 유지하는 경우
    - 별도 병합 커밋 없이, 현재 브랜치의 HEAD를 병합 대상 브랜치의 최신 커밋으로 ‘단순 이동’
    - 이력이 직선으로 이어져서 깔끔하지만, 병렬로 크게 갈라진 작업에는 적용 불가
2. **3-Way Merge**
    - 메인 브랜치와 작업 브랜치가 서로 다른 커밋을 병렬로 쌓아온 상황
    - 공통 조상(merge base)을 찾아 두 브랜치의 차이점을 결합하며, 새로운 병합 커밋이 생긴다
    - 여러 갈래로 분기된 복잡한 이력도 모두 살리면서 병합 가능
    - 충돌이 발생할 수 있으나, 제대로 해결하면 전체 변경 이력을 보존하면서 통합할 수 있다

## 1.2 커밋 시나리오와 커밋 그래프

아래 시나리오에서는 main 브랜치에서 기능이 어느 정도 완성된 뒤, **새로운 기능**을 추가하기 위해 브랜치를 분기한 후 다시 병합하는 과정을 보여준다.

### 1.2.1 Fast-forward 예시

```
main 브랜치
A → B               (아직 분기 전)
     \
      C → D        (새 기능 작업)
      feature/profile 브랜치

```

- **A, B**: 메인 브랜치의 기존 코드
- B 시점에서 **feature/profile** 브랜치를 생성한 뒤, C, D 커밋으로 ‘프로필 기능’ 개발을 진행함
- 이후 메인 브랜치에는 아무 커밋도 쌓이지 않았으므로, 병합 시 Fast-forward가 가능
**병합 명령 예시:**

```bash
$ git checkout main
$ git merge feature/profile

```

**병합 결과(커밋 그래프):**

```
(main 브랜치)
A → B → C → D

```

- 병합 커밋 없이, main이 단순히 C, D 커밋을 그대로 이어받아 직선형 이력을 형성함

### 1.2.2 3-Way Merge 예시

이번에는 메인 브랜치에서도 추가 작업(E 커밋)이 이뤄졌고, 동시에 다른 브랜치에서 기능(F, G 커밋)이 개발되었다고 가정한다.

```
main 브랜치
A → B → C → E
      \
       F → G
       feature/payment 브랜치

```

- **A, B**: 기존 커밋
- **C, E**: 메인 브랜치에서 새 로직이 추가됨
- **F, G**: 분기된 브랜치(feature/payment)에서 결제 기능 추가
**병합 명령:**

```bash
$ git checkout main
$ git merge feature/payment

```

**병합 결과(커밋 그래프):**

```
main 브랜치
A → B → C → E → M  (Merge Commit)
      \         ↑
       F → G ---|
       feature/payment 브랜치

```

- **M**: 새로운 병합 커밋(3-Way Merge)
- 메인 브랜치와 결제 기능 브랜치의 이력을 모두 포함하며, 충돌이 없었다면 자동 병합된다
- 충돌이 있다면, 병합 전에 개발자가 충돌 부위를 수동으로 조정해야 한다(다음 장에서 설명)

# 2. 충돌 해결하기

## 2.1 개념

- *충돌(conflict)**은 서로 다른 브랜치에서 **같은 파일, 같은 부분**을 다르게 수정했을 때 발생한다. Git은 자동으로 합칠 수 없으므로, 개발자가 **어느 부분을 유지할지** 수동으로 결정해야 한다.
- **충돌 예시**
    - `main` 브랜치에서 함수명을 `calculatePrice()`로 변경
    - `feature/discount` 브랜치에서 같은 함수명을 `calcPrice()`로 변경
    - 동일 파일, 동일 라인에서 다른 변경 사항이 발생하여 충돌

⠀충돌이 발생하면 Git이 `<<<<<<< HEAD`, `=======`, `>>>>>>> 브랜치명` 구역을 생성해 수정 충돌을 표시한다.

## 2.2 이해를 돕기 위한 시나리오와 커밋 그래프

아래는 **UI 파일**을 수정하는 과정을 가정한 간단한 예시다.

### 2.2.1 충돌 전 작업 상황

```
main 브랜치
A → B
      \
       X  → Y
       feature/ui-fix 브랜치

```

- **A, B**: `main` 브랜치에서 일반 로직 개발 및 UI 일부 수정
- B 시점에서 `feature/ui-fix` 브랜치를 생성하여, X, Y에서 UI 색상이나 텍스트를 변경
이 와중에 `main` 브랜치에서도 C, D 커밋이 추가되었다고 가정하자.

```
main 브랜치
A → B → C → D
      \
       X → Y
       feature/ui-fix

```

- **D**: `main` 브랜치에서 동시에 UI 부분(`feature/ui-fix` 브랜치 Y 커밋과 같은 파일, 같은 라인) 수정

### 2.2.2 병합 시 충돌 발생

```bash
$ git checkout main
$ git merge feature/ui-fix

```

**커밋 그래프 (충돌 발생 직전 상태):**

```
main 브랜치
A → B → C → (D)*
      \
       X → (Y)*
       feature/ui-fix

```

Git이 자동으로 병합을 시도하지만, B와 X가 분기된 후 **D 커밋과 Y 커밋**에서 같은 라인을 다르게 수정했으므로 충돌 메시지를 표시한다.

### 2.2.3 충돌 해결 단계

1. **충돌 파일 열기**
    - 예: `src/templates/mainPage.html`에서 충돌 발생
    - Git이 추가한 구분자로 어느 부분이 각 브랜치의 수정인지 표시
2. **충돌 부분 수동 편집**
    - `<<<<<<< HEAD` (`main` 브랜치 변경 내용)
    - `=======`
    - `>>>>>>> feature/ui-fix` (`feature/ui-fix` 브랜치 변경 내용)
    - 충돌 표시를 제거하고, 최종적으로 원하는 내용으로 편집
3. **커밋**
    
    ```bash
    $ git add src/templates/mainPage.html
    $ git commit
    
    ```
    
    - 병합 커밋(M)이 생성되며, 충돌 해결 완료
    **최종 그래프:**

```
main 브랜치
A → B → C → D → M  (Merge Commit)
      \         ↑
       X → Y ---|
       feature/payment 브랜치

```

- **M**: 충돌 해결 내용이 반영된 최종 병합 커밋

# 마무리

- **브랜치 병합**은 병렬로 진행된 여러 작업 흐름을 하나로 합치는 핵심 Git 기능이다.
- **Fast-forward**는 직선 이력에 적합하고, **3-Way Merge**는 서로 다른 경로로 진행된 커밋을 새로운 병합 커밋으로 통합한다.
- **충돌**은 같은 파일 동일 라인을 다르게 수정한 경우 발생하며, Git이 자동으로 해결 불가하므로 수동으로 정리해야 한다.
- 충돌 해결은 단순히 코드를 합치는 것을 넘어, “어떤 변경 사항이 최종적으로 유효한가”를 결정하는 중요한 협업 절차다.

위 과정을 충분히 실습하면, Git을 활용해 여러 사람이 동시에 작업해도 안정적으로 하나의 통합 버전을 만들어낼 수 있다.

### 브랜치 전략 이해

이번 교재에서는 여러 개발자가 동시에 작업하는 실무 환경에서 효율적으로 브랜치를 운영하기 위한 **브랜치 전략**에 대해 살펴본다. 단순히 개인 프로젝트에서 브랜치를 분기·병합하는 것을 넘어, 팀 단위 협업에서 어떻게 브랜치를 구성하고 관리할지 전략적으로 이해해야 한다. 대표적인 예로 **Git Flow**와 **GitHub Flow**가 있으며, 각각의 특징과 장단점을 알아본다.

# 1. Git Flow

## 1.1 개념과 주요 브랜치

**Git Flow**는 Vincent Driessen이 제안한 브랜치 전략으로, 규모가 큰 프로젝트에서 여러 릴리스, 핫픽스, 기능 개발을 체계적으로 관리하기 위해 고안되었다. 다음과 같은 주요 브랜치를 두고 운영한다.

![image.png](attachment:920a90d4-e370-4a6e-9261-b17afe88fc0f:image.png)

1. **main**
    - 제품의 최종 릴리스 버전을 관리하는 브랜치
    - 언제든지 안정적인 코드를 유지해야 하며, 버전 태그도 주로 이 브랜치에서 생성한다
2. **develop**
    - 다음 릴리스에 포함될 기능들이 병합되는 브랜치
    - main과 달리, 아직 완벽히 안정화되지 않은 새로운 코드가 계속해서 합쳐진다
3. **feature/**
    - 새 기능을 개발할 때 만들어지는 브랜치들 (예: feature/login, feature/payment)
    - 작업이 완료되면 develop 브랜치로 병합한다
4. **release/**
    - 릴리스 직전에 발생할 수 있는 마지막 버그 수정이나 테스트를 수행하는 브랜치
    - 필요하다면 release 브랜치에서 수정 후, develop과 main에 병합한다
5. **hotfix/**
    - 운영 중인 서비스에서 긴급하게 수정해야 할 문제가 발생했을 때 생성하는 브랜치
    - main에서 분기하고 수정이 끝나면 다시 main과 develop에 반영하여 코드 이력을 동기화한다

## 1.2 Git Flow의 장단점

- **장점**
    - 복잡한 프로젝트에서 버전(릴리스), 기능, 핫픽스를 명확히 구분하여 체계적으로 관리 가능
    - 여러 팀원이 동시에 다양한 기능을 개발해도, 최종적으로 develop에 모이는 흐름이 명료해 협업이 수월함
- **단점**
    - 브랜치가 여러 개(특히 release와 hotfix)가 생기므로 소규모 프로젝트에서는 오히려 관리 부담이 늘어날 수 있음
    - 릴리스 과정을 까다롭게 운영해야 한다면 적합하지만, 단순한 프로젝트에는 과도한 구조가 될 수 있음
    ⠀

# 2. GitHub Flow

![image.png](attachment:63d4ad3a-7752-40d0-9b9b-1c2baa941204:image.png)

## 2.1 개념과 주요 특징

**GitHub Flow**는 GitHub에서 제안하는 브랜치 전략으로, 단순하고 가벼운 프로세스가 특징이다. 주로 배포가 빈번하거나 규모가 비교적 작은 프로젝트에서 사용된다. 핵심 아이디어는 **메인 브랜치(main)는 언제나 배포 가능한 상태**를 유지하고, 새로운 작업은 모두 짧게 분기(브랜치)했다가 Pull Request로 합치는 방식이다.

1. **main**
    - 항상 배포 가능한 상태를 유지하고, 기능 완성 시점마다 수시로 배포 가능
2. **feature/**
    - 메인에서 분기해서 원하는 작업(새 기능, 버그 수정)을 완료하고, 리뷰(Pull Request)를 거쳐 메인에 합친 뒤 즉시 배포
    - 작업이 끝나면 해당 브랜치는 바로 삭제하여 이력을 간결하게 유지

## 2.2 GitHub Flow의 장단점

- **장점**
    - 메인 브랜치가 가볍고 항상 배포 가능 상태이므로, 지속적 배포(CD)와 궁합이 좋음
    - 브랜치와 Pull Request 위주의 단순 프로세스여서 도입이 쉽고, 관리를 단순화할 수 있음
- **단점**
    - 릴리스 단위가 잦고, 명확한 릴리스 단계를 구분해야 하는 대규모 프로젝트에는 다소 부족할 수 있음
    - “기능이 완성되는 즉시 배포”라는 전제가 깔려 있으므로, 배포 시점과 안정성 확보 전략이 명확해야 함
    ⠀

# 3. 브랜치 전략 선택 시 고려 사항

## 3.1 팀 규모와 릴리스 주기

- **팀 규모가 크고, 릴리스가 정기적**이라면 **Git Flow**처럼 명확한 릴리스 브랜치(Release)와 핫픽스(Hotfix)를 구분해 운영하는 것이 좋다.
- **소규모 팀이 잦은 배포를 원하는 경우**에는 간단한 **GitHub Flow**가 효율적이다.

## 3.2 프로젝트 복잡도

- **서로 의존성이 높은 여러 기능**이 동시에 개발되어야 하거나, **버전별 롤백**이 자주 필요하다면 구조적인 **Git Flow**가 안정적이다.
- **단순한 프로젝트**에서는 불필요한 브랜치가 많아지면 오히려 혼란이 생길 수 있으므로, 단순한 방법을 택하는 편이 낫다.

## 3.3 자동화·배포 파이프라인 여부

- CI/CD 환경에서 **매우 빈번하게 배포**한다면, Pull Request 단위로 바로 배포하기 좋은 **GitHub Flow**를 고려해볼 수 있다.
- 정해진 릴리스 사이클(예: 2주나 한 달 단위)이 있다면, **Git Flow**에서 release 브랜치를 통해 안정성 검증을 집중적으로 수행하는 전략이 유용하다.

# 4. 정리

- **Git Flow**: 대규모, 정기 릴리스, 구체적 브랜치 역할 분할 → 구조적이고 체계적인 관리 가능
- **GitHub Flow**: 단순, 지속적인 배포, Pull Request 기반 → 가볍고 빠른 협업에 적합
- 팀 규모, 릴리스 주기, 프로젝트 특성, 자동화 환경 등 여러 요소를 고려하여 적절한 브랜치 전략을 선택하는 것이 중요하다.

이상으로 **브랜치 전략 이해** 챕터를 마친다. 실제 프로젝트에 적용하기 전에, 각 전략의 흐름을 시뮬레이션해보고 팀원들과 합의된 기준을 마련하면 협업 효율을 높일 수 있다.

## Git을 이용해 협업하기

### 원격 저장소 활용하기

이번 교재에서는 원격 저장소와 실제로 상호작용하는 주요 Git 명령어들을 다룬다. 이전 챕터에서 “원격 저장소의 개념과 필요성”을 배경 지식으로 학습했다면, 이제는 로컬 저장소와 원격 저장소 간에 코드를 주고받는 구체적인 단계를 살펴보게 된다. 원격 저장소를 등록하고, 복제(clone)한 뒤, 로컬 변경 사항을 업로드(push)하거나 원격 변경 사항을 내려받아(pull, fetch) 동기화하는 과정을 익힌다.

# 1. 원격 저장소 연결

## 1.1 git remote: 원격 저장소 관리

원격 저장소 정보를 추가하거나 조회, 삭제 등의 작업을 수행하는 명령어이다. 일반적으로 GitHub의 URL(HTTPS/SSH)을 원격 저장소로 등록해 사용한다.

### 1.1.1 원격 저장소 추가 (git remote add)

**원격 저장소를 프로젝트에 등록하기 위한 명령어**

```bash
$ git remote add origin <원격 저장소 URL>

```

- `origin`이라는 별칭(Remote Name)은 관례적으로 많이 사용된다.
- SSH로 등록하려면 `git@github.com:사용자명/저장소명.git` 형태의 SSH URL을 사용한다.

### 1.1.2 원격 저장소 목록 확인 (git remote -v)

**현재 로컬 저장소에 등록된 원격 저장소 정보**를 확인할 수 있다.

```bash
$ git remote -v

```

- push/pull에 사용되는 URL 정보가 표시된다.

### 1.1.3 원격 저장소 삭제/이름 변경

불필요해진 원격 저장소나, 명칭을 변경할 때 사용한다.

```bash
# 원격 저장소 삭제
$ git remote remove <별칭>

# 원격 저장소 이름 변경
$ git remote rename <기존별칭> <새별칭>

```

## 1.2 git clone: 원격 저장소 복제

**원격 저장소를 그대로 복제하여 로컬에 저장소를 생성**하는 명령어이다.

### 1.2.1 HTTPS와 SSH 프로토콜 차이

- **HTTPS**: 매번 사용자명/비밀번호 또는 토큰 입력이 필요하다.
- **SSH**: 사전에 등록한 SSH 키를 통해 안전하게 인증한다. 협업 시 반복되는 인증 과정을 자동화하기 용이하다.

### 1.2.2 기본 사용 예시

**로컬에 디렉토리를 생성하면서 원격 저장소를 복제**한다.

```bash
# HTTPS로 복제
$ git clone <https://github.com/사용자명/저장소명.git>

# SSH로 복제
$ git clone git@github.com:사용자명/저장소명.git

```

- 명령어 실행 후, `저장소명` 디렉토리가 생성되고 내부에 `.git` 폴더가 포함된다.
- 복제된 로컬 저장소에는 이미 `origin`이라는 원격 저장소 별칭이 설정되어 있다.

### 1.2.3 클론 옵션 이해하기

- `-branch 브랜치명`: 특정 브랜치만 내려받아 체크아웃한다.
- `-depth 1`: 가장 최근 커밋(깊이 1)만 가져온다(히스토리 최소화). 큰 저장소를 빠르게 복제할 때 유용하다.
⠀

# 2. 원격 저장소 동기화

## 2.1 git push: 변경사항 업로드

로컬에서 작업한 커밋을 원격 저장소에 반영하는 명령어이다.

### 2.1.1 브랜치 푸시

```bash
$ git push origin main

```

- 로컬 `main` 브랜치가 원격 `origin/main`으로 업로드된다.
- 처음 푸시 시점에 원격 브랜치가 없으면 자동 생성된다.
- “이전 챕터에서 다루었듯이” 브랜치를 관리하고 작업하는 방식은 Git 브랜치 단원에서 자세히 학습했다.

### 2.1.2 태그 푸시

```bash
git push origin <태그명>
# 모든 태그를 한 번에 푸시하고 싶다면:
git push origin --tags

```

- 로컬에 생성된 태그를 원격에도 동일하게 반영한다.
- 버전 관리 시 태그를 활용해 특정 릴리스 상태를 표시한다.

## 2.2 git pull: 원격 변경사항 가져오기

원격 저장소의 최신 변경 내용을 로컬로 내려받고, 자동으로 병합까지 수행한다.

```bash
git pull origin main

```

- 원격 `origin/main`을 로컬 `main`에 병합한다.
- **pull = fetch + merge**의 개념.
- 충돌이 발생하면 수동으로 해결 후 커밋해야 한다.

### 2.2.1 pull과 merge의 관계

- `git pull`은 내부적으로 `git fetch`와 `git merge` 과정을 자동으로 처리한다.
- 병합 과정에서 충돌이 발생하면 사용자가 충돌 파일을 수정하고 커밋해야 최종 반영된다.

### 2.2.2 pull 충돌 해결하기

1. **충돌 파일에서 ‘<<<’, ‘===’, ‘>>>’ 표시 확인**
2. **원하는 코드만 남기고 나머지를 삭제**
3. 수정본을 저장하고 `git add <파일명>` 후 `git commit`
4. 충돌이 해결되면 로컬 브랜치에 병합이 완료된다.

## 2.3 git fetch: 원격 변경사항 확인

원격 저장소의 변경 이력만 내려받고, **로컬 브랜치에는 자동으로 병합하지 않는** 명령어이다.

### 2.3.1 fetch와 pull의 차이점

- `git pull`은 가져온 변경사항을 즉시 로컬 브랜치에 병합한다.
- `git fetch`는 원격 브랜치 내용을 로컬에 내려받되, 병합 여부는 사용자가 선택한다.

```bash
$ git fetch origin

```

- `origin`에 있는 모든 브랜치/태그 정보를 업데이트하지만, 로컬 브랜치는 변경되지 않는다.

### 2.3.2 원격 브랜치 관리

- fetch 후 원격 브랜치 상태를 확인하려면, `git branch -r` 명령어 사용.
- 필요 시 `git merge origin/<브랜치명>`를 통해 수동 병합할 수 있다.
⠀
이상으로 원격 저장소를 등록하고 복제(clone)한 뒤, 로컬 변경 사항을 업로드(push)하거나 원격 변경 사항을 내려받아(pull, fetch) 동기화하는 과정을 살펴보았다.
다음 챕터에서는 **GitHub 협업 기능**(특히 Pull Request 중심)과 코드를 검토·병합하는 워크플로우를 더욱 심도 있게 학습할 예정이다.

### GitHub 협업 기능 활용하기

이번 교재에서는 **GitHub 협업 기능**을 활용하는 방법을 중심으로 학습한다. 특히, 브랜치 기반으로 작업한 뒤 Pull Request(이하 PR)를 통해 코드 리뷰를 진행하고, 팀원들과 효율적으로 협업하는 프로세스를 중점적으로 살펴본다. 또한, 외부 프로젝트나 오픈소스 기여 시 Fork를 활용하는 방법도 다룬다.

# 1. Pull Request 이해하기

## 1.1 PR의 개념과 필요성

- **브랜치 기반 작업**
이전 챕터에서 학습한 브랜치를 이용해 독립적으로 기능을 개발하고, 완성된 코드를 합치는 방식이 협업의 기본이다.
- **코드 리뷰의 중요성**
개발 과정에서 발생할 수 있는 오류, 개선 사항 등을 미리 점검하며, 코드 품질과 유지보수성을 높일 수 있다.
- **PR을 통한 품질 관리**
작성된 코드를 병합하기 전, 다른 팀원들이 PR 화면을 통해 변경 사항을 검토하고 피드백을 제공한다.
이를 통해 무분별한 코드 반영을 방지하고, 프로젝트의 안정성과 일관성을 보장한다.

## 1.2 PR 활용하기

### 1.2.1 PR 생성과 관리

1. **브랜치 푸시**
    - 독립된 기능(브랜치)에서 작업을 마친 뒤, 해당 브랜치를 원격 저장소에 푸시한다.
2. **GitHub 웹 인터페이스에서 PR 생성**
    - “Compare & pull request” 버튼을 클릭해 PR을 작성한다.
    - PR 제목(Title), 내용(Description)에는 변경 목적과 주요 변경 사항을 간략히 기술한다.
3. **PR 진행 상황 모니터링**
    - 팀원들의 리뷰 의견이 올라오면, 해당 의견에 답변하거나 코드를 수정할 수 있다.
4. **PR 머지(Merge)**
    - 리뷰가 완료되고 승인이 떨어지면, main(또는 배포용) 브랜치에 코드를 병합한다.
    - Merge 방식에는 일반 merge, squash merge 등이 있으며, 팀 합의에 따라 선택한다.

### 1.2.2 PR 템플릿 활용

- **PR 템플릿 파일**
    - 저장소 내 `.github/pull_request_template.md` 파일을 생성해두면, PR 작성 시 자동으로 적용되는 서식을 정의할 수 있다.
    - 체크리스트, 관련 이슈 링크, 변경된 기능 요약 등을 포함하여 협업 효율을 높인다.
- **리뷰어 지정과 멘션**
    - 리뷰어로 지정된 사람에게 알림이 전송되어, 코드 검토 요청을 효율적으로 전달한다.
    - 멘션(`@사용자명`) 기능을 통해 특정 팀원에게 직접적인 피드백을 요청할 수도 있다.
    ⠀

# 2. 효과적인 코드 리뷰

## 2.1 PR 설명 작성법

- **변경 요약**: 기능 추가, 버그 수정 등 변경 목적을 간단명료하게 작성한다.
- **관련 이슈**: 이슈 트래커를 사용하는 경우, `“Closes #이슈번호”` 형태로 연결해 작업 추적성을 높인다.
- **검증 항목**: 테스트 시나리오, 실행 환경, 주의 사항 등을 정리해 리뷰어가 빠르게 검증할 수 있도록 한다.

## 2.2 리뷰어와 작성자의 역할

- **리뷰어(Reviewer)**
    - 코드를 직접 실행하거나, 변경된 로직을 점검하며 개선점을 찾는다.
    - 단순한 오류 발견 외에도 리팩토링, 아키텍처 구조 등 전체적인 품질 개선을 제안한다.
- **작성자(Author)**
    - 리뷰 피드백을 확인하고, 필요한 경우 코드를 수정하거나 추가 의견을 제시한다.
    - 변경 사항 반영 후, 다시 커밋하면 PR에 자동으로 업데이트가 누적된다.

## 2.3 건설적인 피드백 주고받기

- **구체적이고 명확하게**: “로직이 잘못된 것 같다”보다는 “이 함수는 O(N^2) 복잡도를 가지므로, O(N)으로 최적화할 수 있는 방법을 고민해보자”와 같이 구체적인 제안을 한다.
- **리뷰 의견 반영과 토론**: 단순 지적보다는 대안이나 추가 아이디어를 공유하며 토론을 이어나간다.

# 3. Fork를 통한 PR 활용

## 3.1 Fork의 개념과 사용 시나리오

- **Fork**: 다른 사람(또는 조직)의 저장소를 복제(Fork)하여, 개인 계정 공간에서 개발을 진행할 수 있도록 해주는 GitHub 기능.
- **Fork 사용 이유**:
    - 오픈소스 프로젝트 기여: 보통 직접 푸시 권한이 없는 외부 기여자들이 Fork를 만들어 Pull Request를 보낸다.
    - 조직 외부인(예: 인턴, 컨트리뷰터)의 안전한 코드 변경 허용.

## 3.2 Fork 기반 협업 설정

### 3.2.1 upstream 저장소 등록

Fork한 저장소는 원본 저장소를 `upstream`으로 등록해둘 수 있다.

```bash
$ git remote add upstream <https://github.com/원본소유자/원본저장소.git>

```

- 이후 `git fetch upstream` 명령어로 원본 저장소의 최신 변경 사항을 가져올 수 있다.

### 3.2.2 Fork 저장소 동기화

- 원본 저장소가 업데이트될 때, 내 Fork 저장소를 최신 상태로 유지하기 위해 merge나 rebase를 활용한다.
- 예) `git pull upstream main` → `git push origin main`

### 3.2.3 기능 개발 및 PR 생성

1. **내 Fork 저장소에서 브랜치 생성**
    - 작업 목적별로 `feature/기능명` 형태의 브랜치를 만든다.
2. **개발 및 커밋**
    - 필요한 수정·추가 작업을 수행하고, 커밋을 쌓는다.
3. **Fork 저장소에 푸시 후 원본 저장소에 PR**
    - PR 대상은 `upstream`의 브랜치(main) 등으로 지정한다.
    - 원본 프로젝트 유지자들이 리뷰 후 병합 여부를 결정한다.

이상으로 GitHub를 통한 협업 기능 전반을 살펴보았다. **Pull Request**를 통해 코드 리뷰 문화를 정착시키고, **Fork**를 활용해 오픈소스나 조직 외부인도 안전하게 기여할 수 있는 방식을 익히는 것이 이번 단원의 핵심이다. 다음 챕터에서는 **실전 협업 시나리오**를 통해, 실제 프로젝트의 브랜치 운용 및 PR 과정을 단계별로 연습해볼 예정이다.

## 실습

### 1. 준비 단계

1. **기본 저장소 준비**
    - 팀장이 GitHub에 원격 Repository 생성(public)
    - 나머지 팀원들은  main 브랜치를 기준으로 원격 repository를 clone 해서 local에 환경을 준비
2. **역할 분담 및 브랜치 생성**
    - 팀장을 포함한 모든 팀원들은 각자 main 브랜치에서 새로운 feature/*** 브랜치를 생성하여 작업 후 commit 하고, push 한다.
    - 팀원 5명이 아래와 같이 역할을 분담합니다.
        - **팀원 A:** 데이터 전처리 파이프라인 개선
        - **팀원 B:** 데이터 증강 기능 추가
        - **팀원 C:** 모델링 – From Scratch 방식 구현
        - **팀원 D:** 모델링 – VGGNet 기반 구현
        - **팀원 E:** 모델링 – ResNet 기반 구현
    
    각 팀원은 main 브랜치에서 자신의 작업을 위한 feature 브랜치를 생성합니다.
    
    ```bash
    $ git checkout -b feature/preprocessing      # 팀원 A
    $ git checkout -b feature/augmentation       # 팀원 B
    $ git checkout -b feature/model-fromscratch    # 팀원 C
    $ git checkout -b feature/model-vggnet         # 팀원 D
    $ git checkout -b feature/model-resnet         # 팀원 E
    
    ```
    

---

### 2. 개별 작업 진행

각 팀원은 자신에게 맡은 역할에 맞게 코드를 수정하거나 기능을 추가합니다.

- **예시 작업 내용**
    - **데이터 전처리:** 결측치 처리, 정규화, 데이터 클렌징 코드 추가
    - **데이터 증강:** 이미지 회전, 플립, 크롭 등의 증강 기법 적용
    - **모델링:** 각자 다른 모델 아키텍처를 구현하여, 초기 학습 결과(예: 정확도, 손실 값 등)를 기록
- 작업 후에는 변경 사항을 커밋하고, 원격 저장소에 feature 브랜치를 푸시합니다.
    
    ```bash
    $ git add .
    $ git commit -m "Implement [전처리/증강/모델링] feature"
    $ git push -u origin feature/[자신의브랜치명]
    
    ```
    

---

### 3. Pull Request(PR) 및 병합

1. **PR 생성**
    
    각 팀원은 GitHub 웹 인터페이스에서 자신의 feature 브랜치에 대해 PR을 생성합니다.
    
    PR 제목 및 설명에는 작업 내용, 구현한 기능, 간단한 테스트 결과 등을 명시합니다.
    
2. **코드 리뷰 및 피드백**
    
    팀원들이 서로의 PR을 리뷰하고, 필요한 개선사항이나 오류에 대해 피드백을 주고받습니다.
    
3. **PR 승인 및 병합**
    
    리뷰가 완료되면(Approve 완료된 PR에 한해서), 팀 리더나 해당 PR 작성자가 PR을 main 브랜치에 병합합니다. 
    
    충돌시에는 해결을 시도합니다. 
    
    병합 후, feature 브랜치는 삭제하여 저장소를 깔끔하게 유지합니다.
    
    ```bash
    $ git branch -d feature/[자신의브랜치명]
    
    ```
    

---

### 4. (선택) README 작성 및 리포지토리 제출

각 팀은 최종적으로 main 브랜치에 병합된 프로젝트를 기반으로, 딥러닝 프로젝트답게 **구조화된 README 파일**을 작성합니다. README에는 다음과 같은 항목이 포함되어야 합니다.

- **프로젝트 개요**: 프로젝트의 목적, 사용한 데이터셋, 주요 기능 등을 간략하게 설명
- **폴더 구조**: 데이터, 코드, 모델, 결과 등 주요 디렉토리 구조를 그림 또는 리스트 형태로 작성
- **실행 방법**: 필요한 패키지, 설치 방법, 학습 및 테스트 실행 방법을 포함
- **모델 설명 및 결과**: 각 모델(From Scratch, VGGNet, ResNet)의 구현 내용, 학습 결과, 성능 비교 등
- **협업 내용**: 각 팀원의 역할 및 협업 과정을 간략히 정리 (옵션)

마지막으로, 작성된 README가 포함된 GitHub 리포지토리 URL을 과제 제출 채널(예: 디스코드 #과제-업로드)에 제출합니다.

---

### 5. 제출 요약

- 강사가 제공한 예제 기본 코드
    
    https://github.com/sprint-ai01/mnist-classification
    
- 팀원 5명이 각자의 feature 브랜치에서 전처리, 증강, 모델링 작업을 진행 후 PR로 main에 병합
- 딥러닝 프로젝트에 적합하게 구조화된 README 파일을 작성
- 최종 리포지토리 URL을 제출